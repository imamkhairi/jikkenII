\documentclass[a4j, titlepage]{jarticle}

\usepackage[dvipdfmx]{graphicx}
\usepackage{fancybox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{colortbl}

\title{情報工学実験II\\ソーティングプログラム}
\author{イマム カイリ ルビス}
\date{\today}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

    \maketitle

    \tableofcontents
    \clearpage

    \section{概要}
        \subsection{ソートアルゴリズムとは}
            ソートアルゴリズムとは，データの要素をある順序に並べるアルゴリズムである．最も頻繁に使用される順序は，数値順と辞書順で、昇順または降順のどちらかである．効率的なソートは，入力データがソートされたデータであることを必要とする他のアルゴリズム（検索やマージアルゴリズムなど）の効率を最適化するために重要である．また，人間が読みやすい出力を作成したりする際にもよく使われる．
            %https://en.wikipedia.org/wiki/Sorting_algorithm
        
        \subsection{計算量}
            アルゴリズムを実行するのにかかるコンピュタの時間を\textbf{時間計算量}(\textit{time complexity})と呼ばれる．時間計算量は，一般的に\textit{big O notation}(オーダー)という書き方で記す．例えば，\textit{O}($n$)，\textit{O}($n \log n$)，\textit{O}($2^n$)，など．

        \subsection{効率的なアルゴリズム}
            効率的なアルゴリズムとは，与えられた課題を最も早く解決するアルゴリズムであると考えることができる．そこで，この実験では，データを数値順に並べるいくつかのソートアルゴリズムを比較し，ある種の数値データに対して、どのアルゴリズムが最も効率的かを調べる．本実験では各プログラムの実行時間は，ソート関数が呼び出される前後のシステム時間差を clock() 関数でカウントされる．

        \subsection{実行環境}
            本実験で使用される実行環境：
            \begin{itemize}
                \item プロセッサ：AMD Ryzen 5 5600X
                \item メモリー：16.0 GB
                \item OS：Windows 11 Pro
                \item コンパイラ：gcc
            \end{itemize}
        
        \subsection{対象データ}
            この実験では，すべてのアルゴリズムがC言語で記述されます．ショーティング対象データは、表(\ref{tab:data})に示すように，異なる特性を持っている．
            \begin{table}[tbh]
                \caption{ソーティング対象データ}
                \label{tab:data}
                \begin{center}
                    \begin{tabular}{lc}
                        \hline
                        ダーた & 特徴 \\ \hline\hline
                        ダーた 1-3 & 乱数\\ 
                        ダーた 4 &  昇順\\ 
                        ダーた 5 &  降順\\ 
                        ダーた 6 &  バイトニック\\ 
                        ダーた 7 &  ジグザグ\\ 
                        でーた 8 & ランダムマイナス\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}

    % bucket sort
    \section{バケットソート}
        バケットソートは、ソートされていない配列要素をバケットと呼ばれるいくつかのグループに分割するソートアルゴリズムです．各バケットは，適切なソートアルゴリズムを使用するか，同じバケットアルゴリズムを再帰的に適用することによってソートされます．

        今回は，入力されたデータの値を配列の添字として，他の配列に格納することにします．そのため，データの個数を数える必要はなく，データの最小値と最大値を知ることが必要．

        \subsection{プログラム}
            以下はバケットソートのプログラムである．
            \lstinputlisting[language=c]{D:/Kosen/jikkenII/sorting/bucket/bucket.c}

        \subsection{動作}
            このアルゴリズムを動けるためには，$(max - min + 1)$ の大きさの配列を用意する必要がある，この理由は後述する．
            
            バケットソートのプログラムの主な流れは，以下の通りである：
            \begin{enumerate}
                \item バケット配列に $(max - min + 1)$ の大きさを設定する．
                \item 出力配列に入力データの大きさを設定する．
                \item 各入力データ$x$はバケット配列の添字 $(x - min)$ 値を $+1$ 増やす．
                \item バケット配列から出力配列に元の値変更し、格納する．
                \item ソート完了．
            \end{enumerate}

        \subsection{時間計算量}
            バケットソートの時間的複雑さは $O(n + k)$ であり，ここでnは要素数，kはバケット配列の大きさである．

            各データに対してバケットソートの実行時間は表（\ref{tab:bucket}）のように表す．ここで表す結果は10回の実行結果の平均値である.

            \begin{table}[tbh]
                \caption{計算時間 (バケットソート)}
                \label{tab:bucket}
                \begin{center}
                    \begin{tabular}{lcccc}
                        \hline
                        \textbf{データ} & data1 & data2 &data3 &data4\\ \hline
                        \textbf{計算時間(ms)} & 7.2712 & 7.2169 & 7.1648 & 6.3128 \\\hline
                        \\ \hline
                        \textbf{データ} &data5 &data6 &data7 &data8\\ \hline
                        \textbf{計算時間(ms)} & 6.1445 & 5.9061 & 7.0154 & 8.6275\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}

        \subsection{改良案}
            入力データをバケット配列の添字に変換するだけでは，マイナスの値に対応できなくなる．マイナスの配列添字はそもそもないからだ．そこで，バケット配列の大きさが$(max - min + 1)$に設定しいないといけない．入力データがすべて同じ数である場合，$ x - x = 0 $ となり，大きさ0の配列はデータを格納できないため、このような場合に $+ 1$ が不可欠．
            \begin{table}[tbh]
                \caption{改良結果}
                \label{tab:bucket_problem}
                \begin{center}
                    \begin{tabular}{|l|c|c|}
                        \hline
                        問題 & 元のアルゴリズム & 改良したアルゴリズム\\ \hline
                        マイナスの対応 & × & ○\\ \hline
                        同じ値データ & ○ & ○\\ \hline
                        バケット配列の大きさ & 大きい & 小さい\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}

        \subsection{考察}
            実行結果から，バケットソートはどのような種類のデータでもうまく動作すると結論付けられる．その差は$1 ms$程度であり，あまりに速すぎて認識できない．

            残りの問題は、小数が持っている数字をソートしようとした場合，小数は配列のインデックスになり得ないということだ．そこで，このアルゴリズムの実装方法について、別の考え方を考えなければならない．


    \section{挿入ソート}
        挿入ソートは，トランプを並べ替えるのと同じような仕組みです．配列は事実上，ソートされた部分とソートされていない部分に分けられます．ソートされていない部分から値が選ばれ，ソートされた部分の正しい位置に配置される．

        今回は，全部の入力データをソートするでなく，入力データを１個ずつ取ってからソートする．
    
        \subsection{プログラム}
            以下は挿入ソートのプログラムである．
            \lstinputlisting[language=c]{D:/Kosen/jikkenII/sorting/insert/insert.c}

        \subsection{動作}
            挿入ソートは比較によりソーティングを行うアルゴリズムである．配列に格納されるデータは，１個前の要素から最初の要素までに比較し、適切の位置に置くこと．しかし，適切の位置に置くという関数がないため，以下の通りである：
            
            \begin{enumerate}
                \item 入力データ $x$ がn番目の要素に入力する．
                \item $(n-1)$ 番目から０番目の要素までに比較する．
                \item 左隣の要素が着目している要素より大きければ，着目している要素の位置に代入する．
                \item 全部ソートされるまで繰り返す．
                \item ソート完了．
            \end{enumerate}
        
        \subsection{時間計算量}
            挿入ソートの計算量は場合によって分れる．
            \begin{itemize}
                % \item 
                \item 最悪の計算量：$O(N^2)$
                \item 平均的な計算量：$O(N^2)$
                \item 最良の計算量：$O(N)$
            \end{itemize}

            各データに対してバケットソートの実行時間は表（\ref{tab:insertion}）のように表す．ここで表す結果は10回の実行結果の平均値である.

            \begin{table}[tbh]
                \caption{計算時間 (バケットソート)}
                \label{tab:insertion}
                \begin{center}
                    \begin{tabular}{lcccc}
                        \hline
                        \textbf{データ} & data1 & data2 &data3 &data4 \\ \hline
                        \textbf{計算時間(ms)} & 3568.585 & 3566.8257 & 3569.5971 & 5.7314\\ \hline
                        \\ \hline
                        \textbf{データ} & data5 &data6 &data7 &data8\\ \hline
                        \textbf{計算時間(ms)} &7068.0738 & 3536.4216 & 3554.4499 & 3535.3692\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}
        
        \subsection{考察}
            実行結果を見るとdata4のソートは最速で，$5.7314ms$ですべてのデータをソートすることができました．挿入ソートは，データがソートされているかどうかを検出することができると結論づけることができます．そのため，すでにソートされたデータに対しては，アルゴリズムが代入処理を行うことはない．
            
            最も時間がかかるのは、データ5(降順)である．これは、データを昇順にソートするために，data5が最も処理時間がかかるからだ．代入の回数を$n$とデータ個数を$m$ｔすると$( n = m + (m-1) + (m-2) + \dots + 1)$，ソートを実行すると、各反復で代入回が増加する．


    \section{バブルソート}
        バブルソートは隣接している要素を比較し，意図する順番になるまで入れ替える．水の気泡が水面に上がっていくように，配列の各要素は反復するごとに末尾に移動していきます．そのため，バブルソートと呼ばれています．

        しかし，今回は要素は末尾に移動するでなく，先頭の方向に移動することにする．そうすると，ソートされた配列は配列の先頭から形成される．

        \subsection{プログラム}
            以下はバブルソートのプログラムである．
            \lstinputlisting[language=c]{D:/Kosen/jikkenII/sorting/bubble/bubble.c}

        \subsection{動作}
            バブルソートは隣接している要素を比較するに基づく．バブルソートのプログラムの主な流れは，以下の通りである：
            \begin{enumerate}
                \item 末尾の要素に着目する．
                \item ソート済の末尾まで比較する．
                \item 全部ソートされるまで繰り返す．
                \item ソート完了．
            \end{enumerate}

        \subsection{時間計算量}
            バブルソートの計算量は$ O(N^2) $である．

            この実験では、バブルソートの改良版も実装しています．これは後で詳しく説明する．
            各データに対してバケットソートの実行時間は表（\ref{tab:bubble}）のように表す．ここで表す結果は10回の実行結果の平均値である.

            \begin{table}[tbh]
                \caption{計算時間 (バケットソート)}
                \label{tab:bubble}
                \begin{center}
                    \begin{tabular}{lcccc}
                        \hline
                        \textbf{データ} & data1 & data2 &data3 &data4 \\ \hline
                        \textbf{（元）計算時間(ms)} & 17405.559 & 17438.424 & 17391.166 & \cellcolor{green!20}5271.074\\ \hline
                        \textbf{（改良）計算時間(ms)} & 18172.166 & 18163.021 & 18152.781 & \cellcolor{green!20}0.109\\ \hline
                        \\ \hline
                        \textbf{データ} & data5 &data6 &data7 &data8\\ \hline
                        \textbf{（元）計算時間(ms)} & 15314.797 & \cellcolor{green!20}10281.237 & 16197.128 & 17328.02\\ \hline
                        \textbf{（改良）計算時間(ms)} & 16301.372 & \cellcolor{green!20}8158.549 & 16487.387 & 18105.532\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}
        
        \subsection{改良案}
            バブルソートは入力データの状態を考えず，隣接している要素を比較する．そうすると，バブルソートはすでにソートされている状態でも，比較を繰り返すことになる．\textbf{一連の比較を行うにおいて，ある時点に交換がなければ，それより先頭側はソート済みである}\cite{cite:boyoh}．これに対して，すでにソートされたデータをチェックして，比較するのはソートされていない部分だけで行うことにする．
        
        \subsection{考察}
            その結果、表（\ref{tab:bubble}）に示すように，data4（昇順）とdata6（バイトニック）では処理時間を減り，残りのデータでは遅くなっタ．これは、データがすでにソートされているかどうかを確認するために，いくつの条件があって，単純比較を行うより処理量は少し増やす．なので，大量のデータに対してこのトレードオフを現れる．

        
    \section{シェーカーソート}
        シェーカーソートは，2つのバブルソートを2つの異なる方向に行うものである．しかし、普通のバブルソートと違って，無駄な繰り返しをしないので、大きな配列でも効率よく処理できます\cite{cite:geek}．これはシェーカーの動きと似ているため，シェーカーソートと呼ばれています．
        % https://www.geeksforgeeks.org/cocktail-sort/

        \subsection{プログラム}
            以下はシェーカーソートのプログラムである．
            \lstinputlisting[language=c]{D:/Kosen/jikkenII/sorting/shacker/shacker.c}
            % benerin lagi comment2 nya
        
        \subsection{動作}
            シェーカーソートのプログラムのプログラムは，以下の通りである：
            \begin{enumerate}
                \item 末尾の要素に着目する．
                \item ソート済の末尾まで比較する．
                \item 全部ソートされるまで繰り返す．
                \item ソート完了．
            \end{enumerate}
\end{document}