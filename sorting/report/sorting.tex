\documentclass[a4j, titlepage]{jarticle}

\usepackage[dvipdfmx]{graphicx}
\usepackage{fancybox}
\usepackage{listings}
\usepackage{xcolor}

\title{情報工学実験II\\ソーティングプログラム}
\author{イマム カイリ ルビス}
\date{\today}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

    \maketitle

    \tableofcontents
    \clearpage

    \section{概要}
        \subsection{ソートアルゴリズムとは}
            ソートアルゴリズムとは，データの要素をある順序に並べるアルゴリズムである．最も頻繁に使用される順序は，数値順と辞書順で、昇順または降順のどちらかである．効率的なソートは，入力データがソートされたデータであることを必要とする他のアルゴリズム（検索やマージアルゴリズムなど）の効率を最適化するために重要である．また，人間が読みやすい出力を作成したりする際にもよく使われる．
            %https://en.wikipedia.org/wiki/Sorting_algorithm
        
        \subsection{計算量}
            アルゴリズムを実行するのにかかるコンピュタの時間を\textbf{時間計算量}(\textit{time complexity})と呼ばれる．時間計算量は，一般的に\textit{big O notation}(オーダー)という書き方で記す．例えば，\textit{O}($n$)，\textit{O}($n \log n$)，\textit{O}($2^n$)，など．

        \subsection{効率的なアルゴリズム}
            効率的なアルゴリズムとは，与えられた課題を最も早く解決するアルゴリズムであると考えることができる．そこで，この実験では，データを数値順に並べるいくつかのソートアルゴリズムを比較し，ある種の数値データに対して、どのアルゴリズムが最も効率的かを調べる．本実験では各プログラムの実行時間は，ソート関数が呼び出される前後のシステム時間差を clock() 関数でカウントされる．

        \subsection{実行環境}
            本実験で使用される実行環境：
            \begin{itemize}
                \item プロセッサ：AMD Ryzen 5 5600X
                \item メモリー：16.0 GB
                \item OS：Windows 11 Pro
                \item コンパイラ：gcc
            \end{itemize}
        
        \subsection{対象データ}
            この実験では，すべてのアルゴリズムがC言語で記述されます．ショーティング対象データは、表(\ref{tab:data})に示すように，異なる特性を持っている．
            \begin{table}[tbh]
                \caption{ソーティング対象データ}
                \label{tab:data}
                \begin{center}
                    \begin{tabular}{lc}
                        \hline
                        ダーた & 特徴 \\ \hline\hline
                        ダーた 1-3 & 乱数\\ 
                        ダーた 4 &  昇順\\ 
                        ダーた 5 &  降順\\ 
                        ダーた 6 &  バイトニック\\ 
                        ダーた 7 &  ジグザグ\\ 
                        でーた 8 & ランダムマイナス\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}

    % bucket sort
    \section{バケットソート}
        バケットソートは、ソートされていない配列要素をバケットと呼ばれるいくつかのグループに分割するソートアルゴリズムです．各バケットは，適切なソートアルゴリズムを使用するか，同じバケットアルゴリズムを再帰的に適用することによってソートされます．

        今回は，入力されたデータの値を配列の添字として，他の配列に格納することにします．そのため，データの個数を数える必要はなく，データの最小値と最大値を知ることが必要．

        \subsection{プログラム}
            以下はバケットソートのプログラムである．
            \lstinputlisting[language=c]{D:/Kosen/jikkenII/sorting/bucket/bucket.c}

        \subsection{動作}
            このアルゴリズムを動けるためには，$(max - min + 1)$ の大きさの配列を用意する必要がある，この理由は後述する．
            
            バケットソートのプログラムの主な流れは，以下の通りである：
            \begin{enumerate}
                \item バケット配列に $(max - min + 1)$ の大きさを設定する．
                \item 出力配列に入力データの大きさを設定する．
                \item 各入力データ$x$はバケット配列の添字 $(x - min)$ 値を $+1$ 増やす．
                \item バケット配列から出力配列に元の値変更し、格納する．
                \item ソート完了．
            \end{enumerate}

        \subsection{時間計算量}
            バケットソートの時間的複雑さは $O(n + k)$ であり，ここでnは要素数，kはバケット配列の大きさである．

            各データに対してバケットソートの実行時間は表（\ref{tab:bucket}）のように表す．ここで表す結果は10回の実行結果の平均値である.

            \begin{table}[tbh]
                \caption{計算時間 (バケットソート)}
                \label{tab:bucket}
                \begin{center}
                    \begin{tabular}{lcccc}
                        \hline
                        \textbf{データ} & data1 & data2 &data3 &data4\\ \hline
                        \textbf{計算時間(ms)} & 7.2712 & 7.2169 & 7.1648 & 6.3128 \\\hline
                        \\ \hline
                        \textbf{データ} &data5 &data6 &data7 &data8\\ \hline
                        \textbf{計算時間(ms)} & 6.1445 & 5.9061 & 7.0154 & 8.6275\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}

        % \subsection{考察}
        %     from the execution result we can conclude that bucket sort run well for any type of data. The difference is only about 1 ms which too fast to even recognized.

        \subsection{問題点}
            入力データをバケット配列の添字に変換するだけでは，マイナスの値に対応できなくなる．マイナスの配列添字はそもそもないからだ．そこで，バケット配列の大きさが$(max - min + 1)$に設定しいないといけない．入力データがすべて同じ数である場合，$ x - x = 0 $ となり，大きさ0の配列はデータを格納できないため、このような場合に $+ 1$ が不可欠．
            \begin{table}[t]
                \caption{改善結果}
                \label{tab:bucket_problem}
                \begin{center}
                    \begin{tabular}{|l|c|c|}
                        \hline
                        問題 & 元のアルゴリズム & 改善したアルゴリズム\\ \hline
                        マイナスの対応 & × & ○\\ \hline
                        同じ値データ & ○ & ○\\ \hline
                        バケット配列の大きさ & 大きい & 小さい\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}

    
    \section{挿入ソート}
        挿入ソートは，トランプを並べ替えるのと同じような仕組みです．配列は事実上，ソートされた部分とソートされていない部分に分けられます．ソートされていない部分から値が選ばれ，ソートされた部分の正しい位置に配置される．

        今回は，全部の入力データをソートするでなく，入力データを１個ずつ取ってからソートする．
    
        \subsection{プログラム}
            以下は挿入ソートのプログラムである．
            \lstinputlisting[language=c]{D:/Kosen/jikkenII/sorting/insert/insert.c}

        \subsection{動作}
            挿入ソートは比較によりソーティングを行うアルゴリズムである．配列に格納されるデータは，１個前の要素から最初の要素までに比較し、適切の位置に置くこと．しかし，適切の位置に置くという関数がないため，以下の通りである：
            
            \begin{enumerate}
                \item 入力データ $x$ がn番目の要素に入力する．
                \item $(n-1)$ 番目から０番目の要素までに比較する．
                \item 左隣の要素が着目している要素より大きければ，着目している要素の位置に代入する．
                \item 全部ソートされるまで繰り返す．
                \item ソート完了．
            \end{enumerate}
        
        \subsection{時間計算量}
            挿入ソートの計算量は場合によって分れる．
            \begin{itemize}
                % \item 
                \item 最悪の計算量：$O(N^2)$
                \item 平均的な計算量：$O(N^2)$
                \item 最良の計算量：$O(N)$
            \end{itemize}

            各データに対してバケットソートの実行時間は表（\ref{tab:insertion}）のように表す．ここで表す結果は10回の実行結果の平均値である.

            \begin{table}[tbh]
                \caption{計算時間 (バケットソート)}
                \label{tab:insertion}
                \begin{center}
                    \begin{tabular}{lcccc}
                        \hline
                        \textbf{データ} & data1 & data2 &data3 &data4 \\ \hline
                        \textbf{計算時間(ms)} & 3568.585 & 3566.8257 & 3569.5971 & 5.7314\\ \hline
                        \\ \hline
                        \textbf{データ} & data5 &data6 &data7 &data8\\ \hline
                        \textbf{計算時間(ms)} &7068.0738 & 3536.4216 & 3554.4499 & 3535.3692\\ \hline
                    \end{tabular}
                \end{center}
            \end{table}
        
        % \subsection{考察}
            % Insertion Sort manage to detect wether a data is sorted or not. The type of data that takes longest time to execute is bitonic data. This can see as the bitonic data takes 3.5 s more time than other data.
    
    \section{バブルソート}
        バブルソートは隣接している要素を比較し，意図する順番になるまで入れ替える．水の気泡が水面に上がっていくように，配列の各要素は反復するごとに末尾に移動していきます．そのため，バブルソートと呼ばれています．

        しかし，今回は要素は末尾に移動するでなく，先頭の方向に移動することにする．そうすると，ソートされた配列は配列の先頭から形成されます．

\end{document}