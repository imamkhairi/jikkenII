\documentclass[a4j, titlepage]{jarticle}

\usepackage[table,xcdraw]{xcolor}
\usepackage[dvipdfmx]{graphicx}
\usepackage{caption}
% \usepackage{subcaption}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{ascmac}
\usepackage{amsmath}
\usepackage{longtable}
\usepackage{subfig}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Define a custom style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single
}

\lstset{style=mystyle}

\begin{document}
  \begin{center}
  \huge 情報工学実験II\par
  \vspace{15mm}
  \huge テーマ03 \par
  \huge グラフ・ネットワークプログラム \par
  \vspace{15mm}
  % \LARGE タイトル \par
  \vspace{20mm}
  \vspace{100mm}
  \Large 令和５年０７月０６日 \par
  \vspace{15mm}
  \Large イマム　カイリ　ルビス \par
  \vspace{10mm}
  \Large 学籍番号：214071\par
  \vspace{10mm}
\end{center}
\clearpage

\tableofcontents
\clearpage

\section{概要}
    \subsection{グラフ理論とは}
    数学においてグラフ理論とは、グラフを研究する学問であり、グラフはオブジェクト間の対関係をモデル化するために用いられる数学的構造である。グラフを構成するためには、点（節点またはノードとも呼ばれる）と辺（枝またはエッジとも呼ばれる）が必要である\cite{bib:wikigraph}。 
    % In mathematics, graph theory is the study of graphs, which are mathematical structures used to model pairwise relations between objects. A graph in this context is made up of vertices (also called nodes or points) which are connected by edges (also called links or lines). \ref{bib:wikigraph}
    グラフ理論には、辺が方向を持っているかどうかによって分れている
    \begin{description}
        \item[有向グラフ]：辺の方向が決まっている一方向性のグラフである。
        \item[無向グラフ]：辺が特定の方向を持たず、双方向性を持つグラフである。
    \end{description}
    本実験では、使用したグラフはすべて無向グラフである。更に、

    \subsection{スタックとは} 
    スタックは、データを一時的にた蓄えるためのデータ構造の一つ。データの出し入れは\textbf{後入れ先出し}（\textit{LIFO / Last In First Out}）で行われる。すなわち、最後に入れられたデータが最初に取り出される\cite{bib:boyoh}。

    なお、スタックにデータを入れる操作を\textbf{プッシュ}（\textit{push}）と呼び、スタックからデータを取り出す操作を\textbf{ポップ}（\textit{pop}）と呼びます\cite{bib:boyoh}。% ini jadikan ga ada sitasi aja kali

    しかし本実験では、実際のスタック機能を模倣するため、ノード数分の大きさを持つ配列を使ってスタックデータ構造を作った。

    \subsection{キューとは}
    キューは、データを一時的に蓄えるための基本的なデータ構造の一つである。最初に入れられたデータが最初に取り出されるという\textbf{先入れ先出し}（\textit{FIFO / First In First Out}）の機構である。\cite{bib:boyoh}
    
    なお、キューにデータを追加する操作を\textbf{エンキュー}（\textit{enqueue}）と呼び、データを取り出す操作を\textbf{デキュー}（\textit{dequeue}）と呼ぶ。また、データが取り出される側を\textbf{先頭}（\textit{front}）と呼び、データが押し込まれる側を\textbf{末尾}（\textit{rear}）と呼ぶ\cite{bib:boyoh}。

    しかし本実験では、実際のキュー機能を模倣するため、ノード数分の大きさを持つ配列を使ってスタックデータ構造を作った。

        \subsubsection{リングバッファによるキュー}
        リングバッファとは、配列の末尾が先頭につながっているとみなすデータ構造である\cite{bib:boyoh}。エンキューとデキューを行うと\textit{front}と\textit{rear}の値は変化する。
        % kasih gambar ring buffer


    
    \subsection{実行環境}
    本実験で使用される実行環境：
    \begin{screen}
        \begin{itemize}
            \item プロセッサ：AMD Ryzen 5 5600X
            \item メモリー：16.0 GB
            \item OS：Windows 11 Pro
            \item コンパイラ：gcc
        \end{itemize}    
    \end{screen}

\section{深さ優先検索と幅優先検索を用いて検索}
    \subsection{深さ優先検索}
    深さ優先探索は、木やグラフのデータ構造を探索するアルゴリズムである。このアルゴリズムは、根（始点）から開始し、バックトラックする前に各辺に沿って可能な限り探索する。

    指定した辺に沿ってこれまでに発見されたノードを追跡し、グラフのバックトラックに役立てるために、スタックが必要となる。

        \subsubsection{深さ優先検索のプログラム}
        以下は深さ優先検索のプログラムである．
        % \lstinputlisting[language=c]{D:/Kosen/jikkenII/netgraph/dfs_connect.c} 
        
        \subsubsection{深さ優先検索のプログラムの動作}
        訪問したすべての点はスタックにプッシュされ、その点から先に行けない場合はスタックトップがポップされる。
        深さ優先検索のプログラムの主な流れは，以下の通りである：
        \begin{screen}
            \begin{enumerate}
                \item 根をスタックにプッシュする。
                \item スタックトップのデータを現在点になるようにピークする。
                \item 現在の点に隣接している最も低い点に訪問する。
                \item 現在点から行き場所はない場合、スタックからポップする。
                \item 全ての点を訪問されるまで繰り返す。
            \end{enumerate}
        \end{screen}
        
    \subsection{幅優先検索}
    幅優先探索は、木やグラフのデータ構造を探索するアルゴリズムである。このアルゴリズムは、根（始点）から開始し、各点に隣接している点を訪問する。

    キューは、訪問されたがまだ探索されていない点を追跡するために必要である。

        \subsubsection{幅優先検索のプログラム}
        以下は深さ優先検索のプログラムである．
        % \lstinputlisting[language=c]{D:/Kosen/jikkenII/netgraph/bfs_connect.c} 
        
        \subsubsection{深さ優先検索のプログラムの動作}
        訪問したすべての点はキューの\textit{rear}にエンキューされ、その点から先に行けない場合はキューの\textit{front}からデキューされる。
        幅優先検索のプログラムの主な流れは，以下の通りである：
        \begin{screen}
            \begin{enumerate}
                \item 根をキューにエンキューする。
                \item キューの\textit{front}のデータを現在点になるようにピークする。
                \item 現在の点に隣接している全ての点を訪問する。
                \item 現在点から行き場所はない場合、キューからデキューする。
                \item 全ての点を訪れるまで繰り返す。
            \end{enumerate}
        \end{screen}
        
    \subsection{深さ優先検索と幅優先検索の結果}
    この問題では、検索対象となるデータが複数用意されている。両プログラムを実行した結果、下表のような結果が得られました。
    % For this problem there are several data that prepared to be searching target for these algoritm. After executing both program, we get result as shown in the table below

    \subsection{深さ優先検索と幅優先検索の考察}
    表を見ればわかるように、どちらのアルゴリズムも木を生成するが、その特性は異なる。すべてをまとめるために、この表の特徴を以下に記す。

    結論として、深さ優先検索は木が長くなるが、各点の子数は少なくなる。
    一方、BFSはツリーは短くなりますが、各点の子数は多くなります。

    % As we can see on the table that both of the algoritm will generate tree but with different characteristic. To sum up everything we write the characteristic on this table below

    % We can conclude that dfs will have higher tree but less number of nodes each vertex, in other hand bfs will have shorter tree but have more kids on each nodes.
    
\section{連結成分数}
連結成分とは、点の各対が辺で結ばれている部分グラフのことである。
この問題では、与えられたデータがどれだけの連結成分を持つかを数えるというものである。
% A connected component is a subgraph in which each pair of nodes is connected with each other via a path.
% In this problem we asked to count how much connected component desired data has. 
    
    \subsection{連結成分数のプログラム}
    この問題に対して、新しいプログラムはないので、プログラムのある部分だけに焦点を当てるつもりである。
    % For this problem there are no new program. So we are only going to focus to this part of the code. ini bagi dua biar jadi dfs sama bfs
    % \lstinputlisting[language=c]{D:/Kosen/jikkenII/netgraph/bfs_connect.c} kayanya bikin file baru deh 
    % code ini sama aja tapi harus comment out hitung2 yang lainnya

    \subsection{連結成分数のプログラムの動作}
    検索問題でも同じプログラムを利用する。このデータには複数の連結要素があるので、スタックやキューが空になるが、この処理はまだ終わっていない。なので、未訪問の点を追加しなければならない。両アルゴリズムの主な流れは，以下の通りである：
    % We utilize the same program for the searching problem before. Since, this data will have several connected component we have to add not visited node every time the stack or queue is empty but the process is not done yet. For both of the algorithm
    \begin{screen}
        \begin{enumerate}
            \item データ構造が空になるまでプログラムを実行する
            \item すべての点を訪問したかどうかをチェックする。
            \item そうでない場合は、最下位の未訪問点をデータ構造に追加する。
            \item すべての点を訪問するまで繰り返す
        \end{enumerate}
    \end{screen}
    言い換えれば、連結成分数を数えるには、この処理が何回繰り返されたかを数えればいい。
    
    \subsection{連結成分数のプログラムの実行結果}
    これらのプログラムを実行した結果、以下のような結果が得られた。
    
    \subsection{連結成分数の結果の考察}
    表からわかるように、どのようなアルゴリズムで連結成分をチェックしても結果は同じである。
    
\section{最大クリーク問題}
クリークとは部分グラフのことで、すべての点が部分グラフの他のどの点とも辺でつながっているのことである。
言い換えれば、最大クリークはより大きなクリークの部分グラフではないクリークである。
% Clique is a subgraph is a graph in which every vertex is connected by an edge to any other vertex in the subgraph.
% a maximal clique is a clique that cannot be extended by including an additional adjacent vertex; in other words a maximal clique is a clique that is not a subset of a larger clique.

    \subsection{最大クリークのプログラム}
    以下は深さ優先検索のプログラムである．
    % \lstinputlisting[language=c]{D:/Kosen/jikkenII/netgraph/dfs_connect.c} 
        
    \subsection{最大クリークのプログラムの動作}
    この問題のプログラムは、実際にはピボットなしのブロンケルボッシュアルゴリズムの実装です。しかし、このコードを作るために修正した点がいくつかある。このアルゴリズムは集合の交差と和を利用するので、すべてのデータを実際の数値として格納する代わりに、インデックスがデータそのものを表す配列を使うことにした。つまり、0は含まれず、1は含まれる。
    % This code actually an implementation of bron kerbosch algorithm without pivoting. But there are several things that i modified to make this code. Since this algorithm utilize intersection and union of set, instead of storing all of the data as an actual number, I choose to use an array with the index represent the data it self. Which means 0 is not included and 1 is included.
    The algorithm it self runs like this:
    
    \subsection{最大クリークの結果}
    In this problem we alse prepared with some set of data. After executing this program to all of the data, we got result like below % mungkin hitung waktu eksekusinya aja
    
    \subsection{最大クリークの考察}
    As we can see the more node the data has, the longer this process take. That is why this algorithm can be improve by choosing pivot in each iteration. The pivot is chosen to minimize the number of recursive calls made by the algorithm, the savings in running time compared to the non-pivoting version of the algorithm can be significant \cite{bib:cazals}. %liat sitasi ini di bron kerbosch algorithm page wiki

\section{発表者の感想}
    Ntar ini mah
    
\end{document}